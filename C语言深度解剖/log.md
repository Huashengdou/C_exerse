# 2018.11.28
- 定义 && 声明
	- 定义是创建对象，并为这个对象分配了内存
	- 声明没有分配内存，仅仅是告诉文件该“名字”已经被占用
- 关键字regist
	- 请求编译器尽可能地将变量存在CPU内部寄存器中，而不是通过内存寻址访问提高效率。就是说不要让编译器优化以register修饰的变量。
	- 注意，在实际编程的过程中是很少用到这个关键字的，我印象中好像就见过一次。
	- 用register修饰的变量必须是能被CPU寄存器接受的类型，这就是说，register的变量必须是一个单个的值，并且其长度小于等于整形的。由于其不能存放在内存中，故不能用取址“&”运算符引用。
	- 引用错误示例：![Aaron Swartz](https://raw.githubusercontent.com/Huashengdou/C_exerse/master/C%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96/%E5%BC%95%E7%94%A8register%E5%8F%98%E9%87%8F%E9%94%99%E8%AF%AF.jpg)
	- 只有局部变量才能使用此关键字。
	- 测试使用register和不使用register的执行效率，见no_register.c和register.c
	
# 2018.11.29
- signed和unsigned关键字的表示范围
	- 计算机内数的表示方法是按照补码进行的。
	- 后面要按照深入理解计算机系统第二章深入学习。
- 堆栈
	- 栈：
		- 是一种数据结构，是只能在一端插入和删除数据的特殊线性表。
		- 允许进行插入和删除操作的一端称为栈顶，另一端称为栈底。
		- 栈按照后进先出的原则存储数据，最先进入的数据被压入栈底，最后进入的数据在栈顶，需要读数据时从栈顶开始弹出数据。
		- 栈顶浮动，栈底固定。栈中元素个数为0时称为空栈。
		- 插入一般称为入栈(push)，删除称为出栈(pop)。
		- 栈也被称为先进后出表，在函数调用的时候用于存储断点，在递归的时候也会用到栈。
		- 栈在计算机系统中，是一个具有以上属性的动态内存区域。压栈的操作使栈顶的地址减小，出栈弹出的操作使栈顶的地址增大。
		- 栈一般存储两方面信息：
			- 函数返回地址和参数；
			- 临时变量：函数的非静态局部变量以及编译器自动生成的其他临时变量。
	- 堆：
		- 是一种动态存储结构，实际上就是数据段中的自由存储区，他是C语言中的一种名称，常用于存储分配动态数据。
		- 堆的存取和释放不存在顺序问题。
		- 堆的分配函数malloc()、calloc()、realloc()三个函数；堆内存释放则使用free()函数。
	- 堆&&栈
		- 堆和栈的“生长”方向相反，栈向低地址方向“生长”，堆向高地址方向“生长”。
	- 例子，main.c

# 2018.11.30
- 在Ubuntu中搭建C开发环境，因为嵌入汇编的程序一直编译不通过。

# 2018.12.1
- 指针数组和数组指针
- 指针数组
	- 定义：int *p[8]
	- 因为优先级的关系，p先于[]结合，说明p是一个数组，然后再与*结合说明数组p的元素是指向整型数据的指针。元素分别为p[0]、p[1]等。相当于8个整形的指针变量，用于存储地址单元，因此p就是数组元素为指针的数组，本质为数组。
- 数组指针
	- 定义：int (*p)[8]
	- p先于括号内的*结合，形成一个指针，该指针指向的是有8个整形元素的数组，p即为指向数组首元素的地址指针，其本质为指针。
- 例子：point.c
- 指针和多维数组
	- 定义：int arr[4][2]
	- 数组名arr是该数组首元素的地址。arr的首元素是一个内含两个int值的数组，所以arr是这个内含两个int值的数组的地址。
	- 因为arr是数组首元素的地址，所以arr的值和&arr[0]的值相同。而arr[0]本身是一个内含两个int类型整数的数组，所以arr[0]的值和他的首元素（一个整数）的地址（即&arr[0][0]）相同。总而言之，arr[0]是一个占用一个int大小对象的地址，而arr是一个占用两个int大小对象的地址。而由于这个整数和内含两个整数的数组都开始于同一个地址，所以arr和arr[0]的值相同。
	- 给指针加1，其值会增加对应类型大小的数值。所以，arr和arr[0]不同，因为arr指向的对象占用了两个int大小，而arr[0]指向的对象占用了一个int的大小。故arr+1和arr[0]+1不同。
	- 解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的[]运算符，得到引用对象代表的值。因为arr是该数组首元素（arr[0][0]）的地址，所以*(arr[0])表示存储在arr[0][0]上的值（即一个int类型的值）。*arr代表数组首元素（arr[0])的值，但是arr[0]本身是一个int类型值的指针。该值的地址是&arr[0][0]，所以*arr就相当于&arr[0][0]。
	- 例子：arr.c

# 2018.12.2
- 宏定义
	- “##”两个＃号表示可变参数中会用到，用于消除后面的逗号。
	- “#”一个表示将变量字符串化。
	- 例子macro.c
	- #pragma参数
		- 设置编译器的状态或者指示编译器完成一些特定的动作
		- #pragma message("消息")，消息在程序编译的时候输出。
		- #pragma once，如果在头文件开头加入此指令，那么就保证头文件只能被编译一次
		- #pragma hsrstop, 表示编译头文件到此为止，后面的不在编译
		- #pragma pack(),设置字节的对齐方式，#pragma pack(2)->两字节对齐；#pragma pack():取消之前的对齐方式
		- #pragma pack(push):保存当前默认的字节对齐方式；#pragma pack(pop):恢复默认的字节对齐方式

# 2018.12.3
- 数值的补码表示
	- 16位的有符号编码中，补码的表示范围为-32768~32767；无符号的补码表示范围为0~65535
	- 为什么-32768没有正的32768与之对应：
	- 第一因为一半的位模式（符号位设置为1的数）表示负数，而另一半（符号位为0的数）表示非负数。因为0是非负数，所以能表示的整数就比负数少一个；
	- 第二，最大的无符号数值刚好比有符号补码的最大值大1。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。-1的有符号补码串和65535的无符号补码串是一样的，都是0xff。数值0在无符号补码和有符号补码中表示方式都是全0的补码串。

# 2018.12.4
- 通常大多数数字都默认是有符号的。
- 当声明为无符号常量时，一般要在数字后面加‘u’或者‘U’，例如12345U。
- 当执行一个运算时，如果它的一个运算数时有符号的而另一个是无符号的，那么C语言会**隐式的**将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
- 例如：判断该运算是否为真：-1<0U。因为第二个运算数是无符号的，第一个运算数就会被隐式的转换为无符号数，因此表达式就等价为4294967295U<0U，这显然是错误的。

# 2018.12.5
- 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

- 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

- 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。

# 2018.12.6
- 大多数计算机对整数使用补码编码，而对浮点数使用IEEE标准754编码。
- 在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的是底层的位模式不变。
- 由于编码长度有限，与传统整数和实数运算相比，计算机运算有不同属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近0.0，从而转换成零时，也会下溢。

# 2018.12.7
- 数组
	- 数组定义时注意，数组长度不能含有变量，但是可以使用#定义的量,或者全局变量,全局变量是不行的，因为可能改变。有的编译器可以，应该是缺陷，不应该允许这种情况出现的。

# 2018.12.10
- 处理器体系
	- 一个处理器支持的指令和指令的字节级编码称为他的指令集体系结构。
	- 计算机原理真的很难啊
# 2018.11.28
- 定义 && 声明
	- 定义是创建对象，并为这个对象分配了内存
	- 声明没有分配内存，仅仅是告诉文件该“名字”已经被占用
- 关键字regist
	- 请求编译器尽可能地将变量存在CPU内部寄存器中，而不是通过内存寻址访问提高效率。就是说不要让编译器优化以register修饰的变量。
	- 注意，在实际编程的过程中是很少用到这个关键字的，我印象中好像就见过一次。
	- 用register修饰的变量必须是能被CPU寄存器接受的类型，这就是说，register的变量必须是一个单个的值，并且其长度小于等于整形的。由于其不能存放在内存中，故不能用取址“&”运算符引用。
	- 引用错误示例：![Aaron Swartz](https://raw.githubusercontent.com/Huashengdou/C_exerse/master/C%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96/%E5%BC%95%E7%94%A8register%E5%8F%98%E9%87%8F%E9%94%99%E8%AF%AF.jpg)
	- 只有局部变量才能使用此关键字。
	- 测试使用register和不使用register的执行效率，见no_register.c和register.c
	
# 2018.11.29
- signed和unsigned关键字的表示范围
	- 计算机内数的表示方法是按照补码进行的。
	- 后面要按照深入理解计算机系统第二章深入学习。
- 堆栈
	- 栈：
		- 是一种数据结构，是只能在一端插入和删除数据的特殊线性表。
		- 允许进行插入和删除操作的一端称为栈顶，另一端称为栈底。
		- 栈按照后进先出的原则存储数据，最先进入的数据被压入栈底，最后进入的数据在栈顶，需要读数据时从栈顶开始弹出数据。
		- 栈顶浮动，栈底固定。栈中元素个数为0时称为空栈。
		- 插入一般称为入栈(push)，删除称为出栈(pop)。
		- 栈也被称为先进后出表，在函数调用的时候用于存储断点，在递归的时候也会用到栈。
		- 栈在计算机系统中，是一个具有以上属性的动态内存区域。压栈的操作使栈顶的地址减小，出栈弹出的操作使栈顶的地址增大。
		- 栈一般存储两方面信息：
			- 函数返回地址和参数；
			- 临时变量：函数的非静态局部变量以及编译器自动生成的其他临时变量。
	- 堆：
		- 是一种动态存储结构，实际上就是数据段中的自由存储区，他是C语言中的一种名称，常用于存储分配动态数据。
		- 堆的存取和释放不存在顺序问题。
		- 堆的分配函数malloc()、calloc()、realloc()三个函数；堆内存释放则使用free()函数。
	- 堆&&栈
		- 堆和栈的“生长”方向相反，栈向低地址方向“生长”，堆向高地址方向“生长”。
	- 例子，main.c

# 2018.11.30
- 在Ubuntu中搭建C开发环境，因为嵌入汇编的程序一直编译不通过。

# 2018.12.1
- 指针数组和数组指针
- 指针数组
	- 定义：int *p[8]
	- 因为优先级的关系，p先于[]结合，说明p是一个数组，然后再与*结合说明数组p的元素是指向整型数据的指针。元素分别为p[0]、p[1]等。相当于8个整形的指针变量，用于存储地址单元，因此p就是数组元素为指针的数组，本质为数组。
- 数组指针
	- 定义：int (*p)[8]
	- p先于括号内的*结合，形成一个指针，该指针指向的是有8个整形元素的数组，p即为指向数组首元素的地址指针，其本质为指针。
- 例子：point.c
- 指针和多维数组
	- 定义：int arr[4][2]
	- 数组名arr是该数组首元素的地址。arr的首元素是一个内含两个int值的数组，所以arr是这个内含两个int值的数组的地址。
	- 因为arr是数组首元素的地址，所以arr的值和&arr[0]的值相同。而arr[0]本身是一个内含两个int类型整数的数组，所以arr[0]的值和他的首元素（一个整数）的地址（即&arr[0][0]）相同。总而言之，arr[0]是一个占用一个int大小对象的地址，而arr是一个占用两个int大小对象的地址。而由于这个整数和内含两个整数的数组都开始于同一个地址，所以arr和arr[0]的值相同。
	- 给指针加1，其值会增加对应类型大小的数值。所以，arr和arr[0]不同，因为arr指向的对象占用了两个int大小，而arr[0]指向的对象占用了一个int的大小。故arr+1和arr[0]+1不同。
	- 解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的[]运算符，得到引用对象代表的值。因为arr是该数组首元素（arr[0][0]）的地址，所以*(arr[0])表示存储在arr[0][0]上的值（即一个int类型的值）。*arr代表数组首元素（arr[0])的值，但是arr[0]本身是一个int类型值的指针。该值的地址是&arr[0][0]，所以*arr就相当于&arr[0][0]。
	- 例子：arr.c

# 2018.12.2
- 宏定义
	- “##”两个＃号表示可变参数中会用到，用于消除后面的逗号。
	- “#”一个表示将变量字符串化。
	- 例子macro.c
	- #pragma参数
		- 设置编译器的状态或者指示编译器完成一些特定的动作
		- #pragma message("消息")，消息在程序编译的时候输出。
		- #pragma once，如果在头文件开头加入此指令，那么就保证头文件只能被编译一次
		- #pragma hsrstop, 表示编译头文件到此为止，后面的不在编译
		- #pragma pack(),设置字节的对齐方式，#pragma pack(2)->两字节对齐；#pragma pack():取消之前的对齐方式
		- #pragma pack(push):保存当前默认的字节对齐方式；#pragma pack(pop):恢复默认的字节对齐方式

# 2018.12.3
- 数值的补码表示
	- 16位的有符号编码中，补码的表示范围为-32768~32767；无符号的补码表示范围为0~65535
	- 为什么-32768没有正的32768与之对应：
	- 第一因为一半的位模式（符号位设置为1的数）表示负数，而另一半（符号位为0的数）表示非负数。因为0是非负数，所以能表示的整数就比负数少一个；
	- 第二，最大的无符号数值刚好比有符号补码的最大值大1。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。-1的有符号补码串和65535的无符号补码串是一样的，都是0xff。数值0在无符号补码和有符号补码中表示方式都是全0的补码串。

# 2018.12.4
- 通常大多数数字都默认是有符号的。
- 当声明为无符号常量时，一般要在数字后面加‘u’或者‘U’，例如12345U。
- 当执行一个运算时，如果它的一个运算数时有符号的而另一个是无符号的，那么C语言会**隐式的**将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
- 例如：判断该运算是否为真：-1<0U。因为第二个运算数是无符号的，第一个运算数就会被隐式的转换为无符号数，因此表达式就等价为4294967295U<0U，这显然是错误的。

# 2018.12.5
- 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

- 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

- 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。

# 2018.12.6
- 大多数计算机对整数使用补码编码，而对浮点数使用IEEE标准754编码。
- 在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的是底层的位模式不变。
- 由于编码长度有限，与传统整数和实数运算相比，计算机运算有不同属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近0.0，从而转换成零时，也会下溢。